# Преимущества кеширующего sw перед HTTP cache

### 1. Возможностей HTTP cache не хватает

Есть сайты, которые пользователь может один раз открыть в браузере, и:

- больше никогда не переоткрывать страницу;
- больше никогда не рефрешить страницу.

просто потому, что для успешной работы со всем функционалом сайта этого не требуется.  
+Весь роутинг может происходить внутри страницы, без прямого обращения к серверу.

Для таких сайтов HTTP cache неспособен на 100% решить проблему актуальности статики, которая может быть запрошена с сервера только один раз при открытии сайта, при рефреше страницы или при смене роута.

### 2. Гибкость настройки кеширования

Кеширующий sw дает возможность реализовать абсолютно любую политику кеширования.

# Режимы работы сервис воркера

**Инициализация** сервис воркера:

- браузер читает файл `sw.js`;
  - последовательно выполняет описанную в `sw.js` логику;
  - создает объекты;
  - открывает соединение с IndexedDB и т.п.

В зависимости от режима работы браузер может взять файл `sw.js`:

- только что скачанный с сервера;
- из какого-то своего внутреннего кеша.

## Обычный режим

Обычный режим работы sw предполагает, что файл `sw.js` на сервере остается неизменным. Соответственно, каждый раз при инициализации браузер берет `sw.js` из своего кеша.

Прежде чем клиенты смогут работать с sw, браузер его инициализирует.  
Если в sw отсутствует активность, тогда браузер может его остановить (полностью прекратить его работу). Интервалы проверки на активность зависят от браузера, например, в хроме это ~30 секунд.  
Если sw остановлен, а от него требуется выполнить работу, тогда браузер <ins>заново</ins> инициализирует sw.  
И вот такой бесконечный цикл: Инициализация -> Останов -> Инициализация -> Останов -> Инициализация -> ... - является ***обычным режимом*** работы sw.

Несколько кейсов для обычного режима (проверено в хроме):

- Рефреш страницы не вызовет переинциализации sw;
- Если закрыть страницу, то какое-то время sw продолжит оставаться в активном состоянии;
- Если на момент открытия страницы(после закрытия) sw еще будет активен, то переинициализации sw не произойдет;
- Если браузер остановил sw, когда страница не закрыта (допустим, пользователь давно переключился на другую закладку с другим сайтом), то активация закладки со страницей с остановленным sw по умолчанию не инициализирует его. А вот когда пользователь выполнит действия на странице, которые потребуют работы от sw, то браузер его проинициализирует.

## Режим "Установка -> Ожидание -> Активация"

### 1. Первая установка

1. Браузер проведет первичную инициализацию sw.
2. Вызовет событие `install`. Если обработка события `install` не выбросила ошибку, тогда следующим сработает событие `activate` и при его успешном завершении sw перейдет в активное состояние – начнет слушать события: `fetch`, `message`, `push`, `sync` и др., и как-то на них реагировать.

### 2. Обновление

События, которые заставят браузер заново скачать с сервера файл `sw.js`:

- открытие/переоткрытие страницы сайта;
- рефреш страницы;
- вызов метода `ServiceWorkerRegistration.update()`;
- также есть мнение, что один раз в 24 часа хром предпринимает самостоятельную попытку скачать `sw.js` с сервера, но надеяться на это не стоит.

Следом за `sw.js` браузер выкачивает все файлы скриптов из `importScripts`.

После каждого цикла скачивания браузер проверяет: "А не изменилось ли содержимое `sw.js`? А не изменилось ли содержимое какого-либо файла из `importScripts`?".  
Если хоть один из файлов изменился, тогда браузер запустит процесс установки новой версии sw:

1. Поднимет и проинициализирует новый инстенс sw. При этом текущий рабочий инстенс sw, тот что со статусом activated, никуда не девается. Поэтому, чтобы избежать всего многообразия проблем многопоточности, надо быть внимательным, если новый и текущий инстенсы sw могут взаимодействовать с расшаренными ресурсами, например: localStorage или IndexedDB.
2. Вызовет событие `install`. Если обработка события `install` не выбросила ошибку, тогда новый sw переходит в режим ожидания до тех пор, пока текущий sw контролирует хотя бы одного клиента. Как только таких клиентов не останется, будет вызвано событие `activate` и после его успешного завершения текущий sw гасится и вместо него начинает использоваться новый sw, который перейдет в активное состояние `activated`.

Если выполнить команду `self.skipWaiting()`, тогда браузер пропустит этап ожидания и после успешного завершенного события `install` сразу вызовет событие `activate`.

### Активного состояния недостаточно

Если был использован `self.skipWaiting()`, то когда новый sw переходит в активное состояние, то клиенты о нем еще ничего не знают.  
Это значит, что, например, в событие `fetch` не будут прилетать сетевые запросы.  
Чтобы sw полностью стал работоспособным, браузер должен привязать к нему клиентов, а для этого надо:

- либо рефрешнуть страницу. Если открыто несколько страниц, то закрыть все кроме одной и ее рефрешнуть;
- либо выполнить `self.clients.claim()`.

### Ошибки в процессе

#### Ошибка возникла на событии `install`

Новая версия sw не установится.  
Повторную попытку установки браузер выполняет согласно алгоритму "2. Обновление" (см. выше). При этом дополнительно вносить изменения в файл `sw.js` на сервере необязательно(разве что ошибку в логике исправить, если она там есть), т.к. браузер его не установил и при следующей попытке он для него будет считаться измененным.

#### Ошибка возникла на событии `activate`

Если процесс дошел до события `activate` – это значит, что новая версия sw уже точно установилась.  
Если при обработке этого события возникнет ошибка, то сделать вторую попытку не получится.  
Поэтому в обработку события `activate` следует добавлять действия, результат которых не может быть критичным при обычном режиме работы нового sw.

# Особенности

### В одной закладке браузера событие 'fetch' всегда вызывается только на одном зарегистрированном sw

Scope sw доступен в `self.registration.scope` и всегда включает origin.  
Предположим на origin `http://localhost:2020` зарегистрировано два sw для scope `/` и `/banana/`, полностью их scope выглядят так:

- для sw#1 = `http://localhost:2020/`
- для sw#2 = `http://localhost:2020/banana/`

Браузер выбирает sw, основываясь на содержимом браузерной строки.  
Например, пользователь перешел по адресу `http://localhost:2020/banana/index.html`, значит браузер задействует sw#2, а следовательно, **любая** сетевая активность пользователя начнет проходить через событие `fetch` sw#2, не важно захочет пользователь получить файл `/123.txt`, `/banana/123.txt` или `/какой/угодно/путь/123.txt`.  
Если пользователь в браузерной строке перейдет по пути `http://localhost:2020/banana-apple/index.html` или `http://localhost:2020/index.html`, тогда браузер задействует sw#1, потому что `/banana-apple/` и `/` подпадают только под scope `http://localhost:2020/`.

Для проверки можно воспользоваться: https://sw-fetch-is-not-limited-by-scope.github.io  
Там один sw на scope `/`, другой на scope `/banana`.  
Каждый sw логирует в консоль запросы, прошедшие через его событие `fetch`.

### Сервис воркер способен работать даже при недоступном сервере

Сервис воркер работает в браузере локально, даже если сейчас недоступен сервер, с которого он был получен.  
Например, sw был установлен с сайта https://my.site.ru.  
Далее вы берете и отключаете сетевое соединение.  
Закрываете браузер.  
Точно можно сказать, что сервис воркер(sw) инициализируется после действий:

- открыть браузер;
- открыть консоль sw: `chrome://serviceworker-internals`;
- в этот момент у всех sw браузера `Running Status: STOPPED`;
- перейти на сайт https://my.site.ru

Браузер вам говорит 'This site can’t be reached', но в консоли у sw сайта `Running Status: RUNNING`.   
В хроме при таких условиях через 30 секунд его статус сменится на `STOPPED`.    
Затем, если вкладка остается активной, то хром самостоятельно попытается его проинициализировать через: 1 мин., 1 мин., 1 мин., 4 мин. - но не могу сказать будет он дальше предпринимать попытки инициализации или нет.

### Сервис воркер может не пробудиться

Браузер всегда старается как можно скорее перевести sw из статуса RUNNING -> в STOPPED.  
Обычно, если sw находится в статусе STOPPED, то перевод в RUNNING происходит по приходу сообщения на листенер `fetch` или `message`.   
Но возникали кейсы, когда sw долго(несколько часов) находится в статусе STOPPED и если послать ему сообщение на листенер `message`, то он не просыпается.

В таком случае перед тем, как послать сообщение на листенер `message`, надо что-нибудь запросить по сети.

### Пропуски при логировании в консоль

Если вы организовали логирование в консоль (в main треде и/или в треде sw), то можете столкнуться с ситуацией, когда логи полностью отсутствуют, либо частичны(вроде бы логов должно быть больше). При этом не важно была у вас открыта консоль или нет(вы заранее выставили Preserve log).  
Такое может произойти, например, когда sw был неактивен много часов и после просыпания одновременно запустилось два sw(один рабочий, второй устанавливается).  
Иногда помогает получить весь лог со стороны sw, если заранее запустить `chrome://serviceworker-internals`.

### Вместо 404 сайт отвечает 200+html с описанием ошибки

На все данные, что мы хотим кешировать, сервер(если эти данные у него отсутствуют) должен возвращать корректную ошибку в HTTP status code.  
В противном случае, если сервер при отсутствии данных отдает, например, статус 200 + html страницу, где сообщается, что произошла такая-то ошибка, тогда в кеш вместо ожидаемого файла попадет эта самая страница. Соответственно, когда браузер вместо, скажем, шрифта получает из кеша содержимое html страницы, то приложение будет работать непредсказуемо.

Варианты решения:

- лучше всего, чтобы сервер при ошибке отвечал одним из статусов ошибки, например, 404;
- положить файл в нужное место -> обновить sw.js, чтобы активировать на клиентах обновление кеша(т.к. кривота уже сохранена в кеше и появление файла на сервере не решит проблему);
- реализовать прекеш с привязкой к Content-Type, если не тот, что ожидается - не кешировать файл.

### Обновление в chrome

В хроме иногда наблюдается следующая последовательность обновления:

- качается новая версия sw файла
- хром чего-то ждет **ровно** 5 минут
- запускает цикл обновления

# События

### `install`

Здесь можно сделать прекеш. При отсутствии прекеша следующая загрузка приложения(сразу после установки/обновления) стартует как если бы кеша нет - все качается по сети, то есть смысл в том, что **небыстро**. А уже после рефреша страницы из кеша.

### `activate`

Здесь можно почистить кеш.

### `fetch`

Сюда браузер заворачивает все запросы пользователя: `GET`, `POST`, `PUT`, `HEAD`, `DELETE`, `PATCH`, `OPTIONS`.  
Для кеширующего sw, наверное, есть смысл обрабатывать только `GET`.

### `message`

Обмен сообщениями между sw и его клиентами.

### `push`

### `sync`

# HTTP кеш

HTTP кеш не должен мешать обновлять файл скрипта sw и скриптов, подключенных через importScripts.

## Политика "Ничего не кешировать, на запрос всегда отдавать то, что есть на сервере"

Сервер должен отдавать файлы со следующей комбинацией заголовков:

- `cache-control: no-store` - этот ресурс нигде и никогда не должен быть закеширован
- `etag` - для надежности должен отсутствовать
- `last-modified` - для надежности должен отсутствовать

## Политика "Проверь изменилась ли версия на сервере"

Сервер должен отдавать файлы со следующей комбинацией заголовков:

- `cache-control: no-cache` - браузер всегда должен сначала сходить на сервер, для проверки последней версии, перед тем, как возьмет файл из своего внутреннего кеша.
- `etag` - опционально
- `last-modified` - опционально

Когда браузер идет на сервер за файлом, то, в зависимости от наличия соответствующих заголовков в ответе от сервера, он может послать заголовки:

- `If-None-Match: [тут значение etag, пришедшее с сервера]`
- `If-Modified-Since: [тут значение last-modified, пришедшее с сервера]`

Браузер сначала проверяет по тегу `If-None-Match`, если тег не изменился, то `If-Modified-Since` игнорируется - браузер сразу вернет 304 Not Modified.

# Ссылки

[Service Worker API](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API)  
[Recipes by Google](https://googlechrome.github.io/samples/service-worker/)  
[Cookbook by Mozilla](https://serviceworke.rs/)

### Гугл принуждает реализовывать offline

- [Updated offline detection logic](https://developer.chrome.com/blog/improved-pwa-offline-detection/#updated-offline-detection-logic), starting in mid-2021
- [What does it take to be installable?](https://web.dev/install-criteria/#criteria)
- [Create an offline fallback page](https://web.dev/offline-fallback-page/)

Первым делом хром проверяет:
1. есть ли rel="manifest"
2. задан ли в манифесте start_url

Если (1) и (2) истина, тогда хром может выполнить проверку на работоспособность в offline:
1) программно перевести браузер в offline
2) выполнить запрос:
- по пути, который указан в манифесте в start_url
- mode: 'navigate'
- redirect: 'follow'
- referrer: ''
- reffererPolicy: 'unsafe-url'
3) запрос само-собой не пройдет с ошибкой: failed net::ERR_INTERNET_DISCONECTED

Ребята из workbox реализовали костыль на такое поведение хрома:  
https://github.com/GoogleChrome/workbox/issues/2749  
Самое интересно то, что начиная с 90 хрома убрали эту оффлайн проверку.  
Я проверил в Canary (на текущий момент 92) - также такой проверки на offline нет.


### Jake Archibald

- [Service Worker Lifecycle](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle)
- [The Offline Cookbook](https://web.dev/offline-cookbook/)
- [Different versions of your site can be running at the same time](https://jakearchibald.com/2020/multiple-versions-same-time/)
- [Service workers and base URIs](https://jakearchibald.com/2016/service-workers-and-base-uris/)
- [Speed up Service Worker with Navigation Preloads](https://developers.google.com/web/updates/2017/02/navigation-preload)

### Progressive Web Apps Training

- [Introduction to Service Worker](https://developers.google.com/web/ilt/pwa/introduction-to-service-worker)
- [Lab: Scripting the Service Worker](https://developers.google.com/web/ilt/pwa/lab-scripting-the-service-worker)
- [Live Data in the Service Worker](https://developers.google.com/web/ilt/pwa/live-data-in-the-service-worker)
- [Caching Files with Service Worker](https://developers.google.com/web/ilt/pwa/caching-files-with-service-worker)

### sw cache vs HTTP cache

- [Prevent unnecessary network requests with the HTTP Cache](https://web.dev/http-cache/)

### habr

- [Service Workers. Инструкция по применению](https://habr.com/ru/company/2gis/blog/345552/)
- [Обновление вашего PWA в продакшене](https://habr.com/ru/post/535428/)
- [Как мы запустили offline-версию сайта RG.RU](https://habr.com/ru/company/oleg-bunin/blog/348150/)
- [Подводные камни Service Workers(когда надо использовать IndexedDB)](https://habr.com/ru/post/351194/)

[Service workers and the Cache Storage API](https://web.dev/service-workers-cache-storage/)
