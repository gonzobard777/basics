# Области видимости и замыкания

1. Фаза **Компиляция**:
    1. **Лексический анализ** – разбиение последовательности символов на осмысленные (с точки зрения языка) фрагменты, называемые _токенами_.
    2. Преобразорвание массива токенов в дерево вложенных элементов, которые в совокупности представляют грамматическую структуру программы. Это дерево называется **Abstract Syntax Tree** - [AST](https://astexplorer.net/).
    3. Создание **иерархии областей видимости**. При этом происходит поднятие объявлений (hoisting) – сначала поднимаются объявления функций, затем  `var` переменных; в процессе поднятия идентификаторы могут переопределяться.
    4. Поиск синтаксических ошибок.
    5. Компиляция байт-кода для движка.
2. Фаза **Исполнение**:
    1. В процессе исполнения байт-кода движек постоянно взаимодействует с соответствующими областями видимости.

## Области видимости

В общем случае **область видимости** – это набор правил, определяющих, где и как движек будет осуществлять поиск идентификаторов.

**Функциональная область видимости** – для любой функции `function(arg1, arg2, ...) {..}` все переменные и функции, объявленные внутри блока `{..}`, + ее аргументы попадают в функциональную область видимости этой функции и недоступны за ее границей.

**Блочная область видимости** – это принадлежность переменных, объявленых через `let` или `const`, произвольному блоку `{..}` Например, произвольный блок `if(..){..}`. Лучше избегать объявление функций в произвольных блоках, либо не вызывать их вне блоков, т.к. поведение может быть неожиданным.

**Лексическая область видимости** определяется на стадии лексического анализа. Другими словами, она определяется тем, где вы разместили переменные, функции и блоки видимости во время написания программы.

![Lexical scope](./data/lexical-scope.png)

В этом примере существуют три области видимости:

- Область (1) охватывает глобальную область видимости и содержит всего один идентификатор: `foo`.
- Область (2) охватывает область видимости `foo` и содержит три идентификатора: `a`, `bar` и `b`.
- Область (3) охватывает область видимости `bar` и включает один идентификатор: `c`.

Область видимости `bar` полностью содержится внутри области видимости `foo`, потому что (и только по этой причине) мы решили определить функцию `bar` именно здесь.  
Неважно, _где_ вызывается функция, и даже _как_ она вызывается – **лексическая область видимости функции** определяется только тем, в каком месте программы эта функция была объявлена.

Так в нашем примере лексической областью видимости функции `bar` является: область (3) + область (2) + область (1).    
Когда движек выполняет команду `console.log(a, b, c)`, то поиск идентификаторов в областях видимости идет в таком порядке: в (3) находит `c` ➜ в (2) находит `a` и `b`.

## Замыкания

**Замыкание** – это способность функции запоминать свою лексическую область видимости и обращаться к ней, даже когда функция вызывается за пределами своей лексической области видимости.

## Checks

```js
a = 2;
var a;
console.log(a);
```

```js
console.log(a);
var a = 2;
```

```js
if (true) {
  console.log(foo);
  const foo = 123;
}
```

```js
function foo(a) {
  console.log(a + b);
  b = 2;
}

foo(2);
```

```js
function foo() {
  var a = 123;
  console.log(a);
}

foo();
console.log(a);
```

```js
function foo(a) {
  console.log(a + b);
}

var b = 2;
foo(2);
```

```js
if (true) {
  var a = 123;
  console.log('if', a);
}
console.log('global', a);
```

```js
if (true) {
  let a = 123;
  console.log('if', a);
}
console.log('global', a);
```

```js
if (true) {
  foo(1);

  function foo(a) {
    console.log(a * 10);
  }
}
foo(2);
```

```js
foo();
if (true) {
  function foo() {
    console.log(1);
  }
} else {
  function foo() {
    console.log(2);
  }
}
```

```js
if (true) {
  function foo() {
    console.log(1);
  }
} else {
  function foo() {
    console.log(2);
  }
}
foo();
```

```js
foo(1);
var foo = (a) => {
  console.log(a * 10);
};
```

```js
var foo = function bar(a) {
  console.log(a * 10);
};
foo(2);
bar(1);
```

```js
for (var i = 1; i <= 5; i++) { // и другой вариант, где: let i = 1 
  const timerId = setTimeout(() => {
    console.log(i);
  }, i * 1000);
}
```

```js
foo();

var foo = 3;

function foo() {
  console.log(1);
}

foo = function foo() {
  console.log(2);
};

foo();
```

```js
foo();

function foo() {
  console.log(1);
}

foo = function foo() {
  console.log(2);
};

function foo() {
  console.log(3);
}

foo();
```
